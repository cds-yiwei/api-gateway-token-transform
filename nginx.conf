worker_processes  1;

# Emit detailed error/debug logs to stderr for debugging while developing.
# Change to a file path and lower log level for production.
# error_log stderr debug;

events { worker_connections 1024; }

http {
    lua_package_path "/usr/local/openresty/lualib/?.lua;;";
    lua_shared_dict jwks_cache 10m;

    # Upstream for oauth2 backend
    # ASSUMPTION: there is an OAuth2 backend reachable at 127.0.0.1:8081
    # If your backend runs elsewhere, update this upstream block accordingly.
    upstream oauth_backend {
        # upstream is an HTTPS service â€” make sure we connect to port 443
        server cds-gcsignin-dev.verify.ibm.com:443;
    }

    resolver 8.8.8.8 valid=30s ipv6=off;
    resolver_timeout 5s;

    server {
        listen 8080;
        # any server_name
        server_name _;

        # Discovery endpoint (reverse proxy)
        location = /oauth2/.well-known/openid-configuration {
            default_type application/json;
            content_by_lua_file conf/lua/handlers/discovery_proxy.lua;
        }

        # # Authorization endpoint (reverse proxy)
        # location = /oauth2/authorize {
        #     default_type application/json;
        #     content_by_lua_file conf/lua/handlers/authorize_proxy.lua;
        # }

        # Token endpoint (reverse proxy)
        location = /oauth2/token {
            default_type application/json;
            content_by_lua_file conf/lua/handlers/token_proxy.lua;
        }

        # Userinfo endpoint (reverse proxy)
        location = /oauth2/userinfo {
            default_type application/json;
            content_by_lua_file conf/lua/handlers/userinfo_proxy.lua;
        }

        # Generic rest request forward (transparent proxy)
        # Match any subpath under /oauth2/ (e.g. /oauth2/foo, /oauth2/a/b)
        # location ~ ^/oauth2(/|$) {
        #     default_type application/json;
        #     content_by_lua_file conf/lua/handlers/rest_forward.lua;
        # }
        location ~ ^/oauth2(/|$) {
            # Forward the upstream hostname as Host so the upstream server/CDN
            # receives the expected Host header. Using $host (the gateway's
            # hostname) caused the upstream to reject the request with
            # "The requested URL "[no URL]" is invalid.". Use the explicit
            # upstream hostname (no port) to ensure SNI and Host match.
            proxy_set_header Host cds-gcsignin-dev.verify.ibm.com;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_pass_request_headers on;
            proxy_pass https://oauth_backend$request_uri;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            # Ensure SNI is sent for TLS handshakes to the upstream host
            proxy_ssl_verify off; # keep off for debugging; re-enable in prod and set proxy_ssl_trusted_certificate
            proxy_ssl_server_name on;
            # Use explicit hostname (no port) for the TLS SNI name. Using $proxy_host can include the port
            # which some upstream servers don't accept as a valid SNI name and may abort the handshake.
            proxy_ssl_name cds-gcsignin-dev.verify.ibm.com;
            # Restrict to modern TLS versions and a safe cipher list to avoid protocol/cipher mismatches
            proxy_ssl_protocols TLSv1.3 TLSv1.2;
            proxy_ssl_ciphers HIGH:!aNULL:!MD5:!LOW:!EXP:!PSK:!SRP:!DSS;
            # timeouts - adjust as needed
            # increase connect timeout slightly for TLS handshake
            proxy_connect_timeout 10s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

        
        # Forward proxy for RP backchannel logout
        location = /rp/backchannel_logout {
            default_type application/jwt;
            content_by_lua_file conf/lua/handlers/logout_forward.lua;
        }

        
    }
}
